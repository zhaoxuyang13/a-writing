\documentclass[9pt]{beamer}

%\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm2e}
\usepackage{color, colortbl}
\usepackage{enumerate}
\usepackage{arydshln}
\usepackage{multirow}

\renewcommand{\figurename}{Fig}
\usetheme{uha}



%\theoremstyle{plain}
%  \newtheorem{theorem}{Theorem}
%  \newtheorem{lemma}{Lemma}
\newtheorem{corrolary}{Corollary}
\newtheorem{claim}{Claim}
\newtheorem{proposition}{Proposition}
\newtheorem{property}{Property}
%  \newtheorem{fact}{Fact}
%\theoremstyle{definition}
%  \newtheorem{definition}{Definition}
%  \newtheorem{example}{Example}
%\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{proviso}{Proviso}


\newcommand{\ccr}[1]{{\color{red}#1}}
\newcommand{\ccb}[1]{{\color{blue}#1}}
\newcommand{\ccp}[1]{{\color{purple}#1}}
\newcommand{\ccm}[1]{{\color{magenta}#1}}
\newcommand{\cco}[1]{{\color{orange}#1}}
\newcommand{\ccy}[1]{{\color{yellow}#1}}
\newcommand{\ccl}[1]{{\color{lime}#1}}
\newcommand{\ccc}[1]{{\color{cyan}#1}}
\newcommand{\ccg}[1]{{\color{gray}#1}}
\newcommand{\ccpk}[1]{{\color{pink}#1}}
\newcommand{\ccov}[1]{{\color{olive}#1}}



\begin{document}
	
%%//////////////////////////////////////////////////////////////////////////////////////////////%%1
	
    \title{Model-Agnostic Meta-Learning (MAML) }
    \subtitle{A Meta-Learning approach for Fast Adaptation of Deep Networks}
    \author{Yuyang Huang, Xuyang Zhao}
    \institute{School of Software, Shanghai Jiao Tong University}
    \date{\hspace{2em}}
    \frame{
    \titlepage
    }

%%//////////////////////////////////////////////////////////////////////////////////////////////%%1

\section{Introduction}


%%//////////////////////////////////////////////////////////////////////////////////////////////%%3
	\frame{
		\frametitle{Introduction: Meta-Learning}

		Meta learning = Learning to learn 

		* \ccr{Meta} + X $\longrightarrow$ X about X

		\centerline{\includegraphics[width=1.0\textwidth]{figs/meta-ml.png}}
	}
	\frame{	
		\frametitle{Introduction: Meta-Learning Background}
		\textbf{A meta-learning model}
		\begin{itemize}
			\item  learns from \ccb{past learning experience}				
			\item  can learn \ccb{future tasks} \ccr{better} based on prior knowledge
		\end{itemize}

		\textbf{Metrics for meta-learning}
		\begin{itemize}
			\item size of training-set for model convergence		
			\item robustness of model
			\item etc...
		\end{itemize}
		
		}
%//////////////////////////////////////////////////////////////////////////////////////////////%%4
	\frame{
		\frametitle{Introduction: Few-shot Learning problem}
	
	\begin{definition}
		An \ccp{$st$-cut (cut)} is a partition \ccb{$(A, B)$} of the nodes with \ccb{$s\in A$} and \ccb{$t \in B$}.
	\end{definition}\pause

	\begin{definition}
 Its \ccp{capacity} is the sum of the capacities of the edges from \ccb{$A$} to \ccb{$B$}.
  \ccb{\[
\operatorname{cap}(A, B)=\sum_{e \text { out of } A} c(e)
\]}\vspace{-1em}
    \end{definition}\pause\bigskip


\centerline{\includegraphics[width=0.65\textwidth]{figures/p4}}
	}
	%%%//////////////////////////////////////////////////////////////////////////////////////////////%%5
	\frame{
	\frametitle{Minimum-cut problem}
	\begin{definition}
		An \ccp{$st$-cut (cut)} is a partition \ccb{$(A, B)$} of the nodes with \ccb{$s\in A$} and \ccb{$t \in B$}.
	\end{definition}

	\begin{definition}
 Its \ccp{capacity} is the sum of the capacities of the edges from \ccb{$A$} to \ccb{$B$}.
  \ccb{\[
\operatorname{cap}(A, B)=\sum_{e \text { out of } A} c(e)
\]}\vspace{-1em}
    \end{definition}\bigskip	
	
	\centerline{\includegraphics[width=0.7\textwidth]{figures/p5}}
}
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%6

	\frame{
	\frametitle{Few-shot Learning problem}
	
    \cco{Min-cut problem.} Find a cut of minimum capacity.\bigskip\bigskip

	\centerline{\includegraphics[width=0.6\textwidth]{figures/p6}}
}

	
%%//////////////////////////////////////////////////////////////////////////////////////////////%%7
		\frame{
		\frametitle{Few shot learning cases: Omniglot}
	Omniglot : Few-shot Classification
\begin{enumerate}[\color{blue} A.]
	\item $11~ (20+25 - 8 - 11 - 9 - 6)$
	\item $34 ~(8+11+9+6)$
	\item $45~ (20+ 25)$
	\item $79~	(20+ 25+ 8+ 11+ 9+ 6)$
\end{enumerate}	
\vspace{5mm}
	
	\centerline{\includegraphics[width=0.8\textwidth]{figures/p7}}
	
}
	
	
	
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%8
	\frame{
		\frametitle{Maximum-flow problem}
	\begin{definition}
		An \ccp{$st$-flow(flow)} \ccb{$f$} is a function that satisfies:
		\begin{itemize}
			\item For each \ccb{$e\in E$}: \hspace{2mm}  \ccb{$0 \leq f(e) \leq c(e)$}
			\item For each \ccb{$v\in V-\{s,t\}$}:  \ccb{$\sum\limits_{e \text { in to } v} f(e) \  =\sum\limits_{e \text { out of } v} f(e)$}
		\end{itemize}
	\end{definition}
	\bigskip

	\centerline{\includegraphics[width=0.8\textwidth]{figures/p8}}
	}
	
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%9
	\frame{
		\frametitle{Maximum-flow problem}
		\begin{definition}
		An \ccp{$st$-flow(flow)} \ccb{$f$} is a function that satisfies:
		\begin{itemize}
			\item For each \ccb{$e\in E$}: \hspace{2mm}  \ccb{$0 \leq f(e) \leq c(e)$}
			\item For each \ccb{$v\in V-\{s,t\}$}:  \ccb{$\sum\limits_{e \text { in to } v} f(e) \  =\sum\limits_{e \text { out of } v} f(e)$}
		\end{itemize}
	\end{definition}
		\begin{definition}
		The \ccp{value}	of a flow \ccb{$f$} is: \ccb{$val(f)=\sum\limits_{e \text { out of } s} f(e)-\sum\limits_{e \text { in to } s} f(e)$}
		\end{definition}\smallskip
	
	\centerline{\includegraphics[width=0.7\textwidth]{figures/p9}}
	}
	
	
%%////////////////////////////////////////////////////////////////////////////////////////////%%10
	\frame{
	\frametitle{Maximum-flow problem}
	
    \cco{Max-flow problem.} Find a flow of maximum value.\bigskip\bigskip


	\centerline{\includegraphics[width=0.7\textwidth]{figures/p10}}
}


\section{Model Agnostic Meta-Learning (MAML)}
	%
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%12
	\frame{
		\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
		\begin{itemize}
			\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
		\ccg{	\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.
			\item Augment flow along path $P$.
			\item  Repeat until you get stuck.}
		\end{itemize}\vspace{5mm}
	
	 	\centerline{\includegraphics[width=\textwidth]{figures/p12}}
	}
	%
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%13

\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{	\item Start with $f (e) = 0$ for each edge $e \in E$.}
		\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$} where each edge has \ccb{$f (e) < c(e)$}.
		\ccg{	\item Augment flow along path $P$.
			\item  Repeat until you get stuck.}
	\end{itemize}\vspace{5mm}
	
		\centerline{\includegraphics[width=\textwidth]{figures/p13}}
}
	%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%14
	%
\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{	\item Start with $f (e) = 0$ for each edge $e \in E$.
		\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.}
		\item Augment flow along path \ccb{$P$}.
		\ccg{	\item  Repeat until you get stuck.}
	\end{itemize}\vspace{5mm}
	
		\centerline{\includegraphics[width=\textwidth]{figures/p14}}
}
	%%%//////////////////////////////////////////////////////////////////////////////////////////////%%15
	
\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{	\item Start with $f (e) = 0$ for each edge $e \in E$.
			\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.
		\item Augment flow along path $P$.}
			\item  Repeat until you get stuck.
	\end{itemize}\vspace{3mm}
	
		\centerline{\includegraphics[width=\textwidth]{figures/p15}}
}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%16
   \frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{\item Start with $f (e) = 0$ for each edge $e \in E$.
			\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.
			\item Augment flow along path $P$.}
		\item  Repeat until you get stuck.
	\end{itemize}\vspace{5mm}

	
		\centerline{\includegraphics[width=\textwidth]{figures/p16}}
}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%17
\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
			\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
			\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$} where each edge has \ccb{$f (e) < c(e)$}.
			\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
	\end{itemize}
\bigskip

	
		\centerline{\includegraphics[width=\textwidth]{figures/p17}}
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%18

  \frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
			\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
			\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$} where each edge has \ccb{$f (e) < c(e)$}.
			\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
	\end{itemize}
\bigskip
	
		\centerline{\includegraphics[width=\textwidth]{figures/p18}}
}
	
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%19

	\frame{
    \frametitle{Why the greedy algorithm fails}
		\ccr{Q.} Why does the greedy algorithm fail?\pause

		\ccc{A.} Once greedy algorithm increases flow on an edge, it never decreases it.
		\pause\smallskip
		
		\cco{Ex.} Consider flow network \ccb{$G$}.	\vspace{-3mm}
		\begin{itemize}
			\item The unique max flow has \ccb{$f^*(v,w)=0$}.
			\item Greedy algorithm could choose \ccb{$s\rightarrow v\rightarrow w \rightarrow t$} as first augmenting path.
		\end{itemize}\smallskip
		
		\centerline{\includegraphics[width=0.4\textwidth]{figures/p19}}\pause
		
	\cco{Bottom line.} Need some mechanism to \ccr{undo} a bad decision.	
	}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%20
	\frame{
		\frametitle{Residual network}
		\vspace{2mm}
	\begin{columns}
		\begin{column}{6cm}
			\ccp{Original edge} \ccb{$e=(u,v)\in E$}.
			\begin{itemize}
				\item Flow \ccb{$f(e)$}.
				\item Capacity \ccb{$c(e)$}
			\end{itemize}	
		\vspace{3mm}
		
			\ccp{Reverse edge}  \ccb{$e^{\text { reverse }}=(v, u)$}
			\begin{itemize}
				\item	\cco{Undo} flow sent.
			\end{itemize}	
		
		\end{column}
	
		\begin{column}{4cm}
	\centerline{\includegraphics[width=\textwidth]{figures/p20}}
	\end{column}
	\end{columns}
\bigskip\pause
	\begin{columns}
		
	\begin{column}{6cm}
\ccp{Residual capacity}
\ccb{$$
c_{f}(e)=\left\{\begin{array}{ll}{c(e)-f(e)} & {\text { if } e \in E} \\ {f(e)} & {\text { if } e^{\text { reverse }} \in E}\end{array}\right.
$$}
  \end{column}
	
	\begin{column}{4cm}
		\centerline{\includegraphics[width=\textwidth]{figures/p20_2}}
	\end{column}
\end{columns}


\ccp{Residual network} \ccb{$G_f=(V,E_f,s,t,c_f)$} 	%$ \color{red}\begin{array}{l}
%\text{\tiny edges with positive}\\[-2mm]
%\text{\tiny residual capacity}\\
%\swarrow\\
%\end{array} $ 	\vspace{-4mm}
\begin{itemize}
		\vspace{-4mm}
	\item \ccb{$E_{f}=\{e : f(e)<c(e)\} \cup\left\{e^{\text { reverse }} : f(e)>0\right\}$}.	%$ \color{red}\begin{array}{l}
%	\text{\tiny where flow on a reverse edge}\\[-2mm]
% \quad	\text{\tiny negates flow on}\\[-2mm]
%	\text{\tiny corresponding forward edge}\\
%	\swarrow\\
%	\end{array} $
% \vspace{-2mm}
	\item Key property: \ccb{$f'$} is a flow in \ccb{$G_f$} iff \ccb{$f+f'$} is a flow in \ccb{$G$}
\end{itemize}
	}
	%%
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%21

\frame{
	\frametitle{Augmenting path}
	\begin{definition}
		An \ccp{augmenting path} is a simple \ccb{$s\rightsquigarrow t$} path in the residual network \ccb{$G_f$}.
	\end{definition}\pause

  \begin{definition}
	The \ccp{bottleneck capacity} of an augmenting path \ccb{$P$} is the minimum residual capacity of any edge in \ccb{$P$}.	
   \end{definition}
  }

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%21

\frame{
	\frametitle{Augmenting path}

    \cco{Key Property.}
    Let \ccb{$f$} be a flow and let \ccb{$P$} be an augmenting path in \ccb{$G_f$}. After calling \ccb{$f'\leftarrow\mathtt{Augment}(f,c,P)$}, the resulting \ccb{$f'$} is a flow and \ccb{$val(f')=val( f )+bottleneck(G_f, P)$}.\pause

    \begin{exampleblock}{}
   % \scalebox{0.9}{
    \begin{algorithm}[H]
        \SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
        \SetKwFunction{Au}{\sc Augment}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
     \Au{$f$,$c$,$P$}
     \BlankLine
     $\delta \leftarrow$ bottleneck capacity of augmenting path P\;
     \For{each edge $e\in P$}{
       \lIf{$(e\in E)$}{$f(e)\leftarrow f(e)+\delta$}
      \Else{$f\left(e^{\text { reverse }}\right) \leftarrow f\left(e^{\text { reverse }}\right)-\delta$}
      }
      \Return $f$\;
     \end{algorithm}
     \end{exampleblock}

     }
	%%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%22
	%
	\frame{
		\frametitle{Network flow: quiz 2}
	Which is the augmenting path of highest bottleneck capacity?
	\begin{enumerate}\color{blue}
		\item $A \rightarrow F \rightarrow G \rightarrow H$
		\item $A \rightarrow B \rightarrow C \rightarrow D \rightarrow H$
		\item $A \rightarrow F \rightarrow B \rightarrow G \rightarrow H$
		\item $A \rightarrow F \rightarrow B \rightarrow G \rightarrow C \rightarrow D \rightarrow H$
	\end{enumerate}	\vspace{3mm}
		\centerline{\includegraphics[width=0.8\textwidth]{figures/p22}}
	}
	%%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%23
	\frame{
		\frametitle{Ford–Fulkerson algorithm}
		\ccp{Ford–Fulkerson augmenting path algorithm.}
		\vspace{-3mm}
		\begin{itemize}
		\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
		\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$}  in the residual network \ccb{$G_f$}.
		\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
		\end{itemize}
	\pause

	\begin{exampleblock}{}
    \begin{algorithm}[H]
        \SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
        \SetKwFunction{FF}{\sc Ford–Fulkerson}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
        \SetKwFunction{Up}{\sc Update}\SetKwFunction{Au}{\sc Augment}
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
     \FF{$G$}
     \BlankLine
     \For{each edge $e \in E$}{$f(e)\leftarrow 0$}
     $G_f\leftarrow $ residual network of $G$ with respect to flow $f$\;

     \While{there exists an $s\rightsquigarrow t$ path $P$ in $G_f$}{
      $f\leftarrow$ \Au{$f$,$c$,$P$}\;
      \Up{$G_f$}\;
      }
      \Return $f$\;
     \end{algorithm}
     \end{exampleblock}

	}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%24

	\section{Algorithms}

	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%25
	
	\frame{
		\frametitle{Relationship between flows and cuts}
		\begin{lemma}
		Let \ccb{$f$} be any flow and let \ccb{$(A,B)$} be any cut. Then, the value of the flow \ccb{$f$} equals the net flow across the cut \ccb{$(A,B)$}.	
		\ccb{\begin{equation*}
	v a l(f)=\sum\limits_{\text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)
		\end{equation*}}
    \end{lemma}
	
	\bigskip
   \centerline{\includegraphics[width=0.8\textwidth]{figures/p25}}
	}
	%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%26
	\frame{
	\frametitle{Relationship between flows and cuts}
		\begin{lemma}
		Let \ccb{$f$} be any flow and let \ccb{$(A,B)$} be any cut. Then, the value of the flow
     \ccb{$f$} equals the net flow across the cut \ccb{$(A,B)$}.	
		\ccb{\begin{equation*}
	v a l(f)=\sum\limits_{\text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)
		\end{equation*}}
    \end{lemma}
	
	\bigskip
\centerline{\includegraphics[width=0.8\textwidth]{figures/p26}}
}
	%
	%%%//////////////////////////////////////////////////////////////////////////////////////////////%%27
	
			\frame{
		\frametitle{Relationship between flows and cuts}
	\begin{lemma}
		Let \ccb{$f$} be any flow and let \ccb{$(A,B)$} be any cut. Then, the value of the flow
     \ccb{$f$} equals the net flow across the cut \ccb{$(A,B)$}.	
		\ccb{\begin{equation*}
	v a l(f)=\sum\limits_{\text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)
		\end{equation*}}
    \end{lemma}
	
	\bigskip
    \centerline{\includegraphics[width=0.8\textwidth]{figures/p27}}
	}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%28
	\frame{
	\frametitle{Network flow: quiz 3}	
	Which is the net flow across the given cut?
	\begin{enumerate}\color{blue}
		\item 11 $ (20+25- 8- 11- 9- 6) $
		\item 26 $ (20+22- 8- 4- 4) $
		\item  42 $ (20+22) $
		\item 45 $ (20+25) $
	\end{enumerate}
	\bigskip
 \centerline{\includegraphics[width=0.8\textwidth]{figures/p28}}
}



	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%29
		\frame{
		\frametitle{Relationship between flows and cuts}
	\begin{lemma}
		Let \ccb{$f$} be any flow and let \ccb{$(A,B)$} be any cut. Then, the value of the flow
     \ccb{$f$} equals the net flow across the cut \ccb{$(A,B)$}.	
		\ccb{\begin{equation*}
	v a l(f)=\sum\limits_{\text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)
		\end{equation*}}
    \end{lemma}\pause

\ccm{\em Proof.}

\ccb{$$\begin{array}{ll}
val(f)&=\sum\limits_{e \text { out of } s} f(e)-\sum\limits_{\text { e in to } s} f(e) \\
&=\sum\limits_{v \in A}\left(\sum\limits_{e \text { out of } v} f(e)-\sum\limits_{\text { e in to } v} f(e)\right)\\
&=\sum\limits_{e \text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e).
\end{array}
$$}


}

	%%//////////////////////////////////////////////////////////////////////////////////////////////%%30
	\frame{
		\frametitle{Relationship between flows and cuts}
		\begin{theorem}{Weak Duality}
         Let \ccb{$f$} be any flow and \ccb{$(A, B)$} be any cut. Then, \ccb{$val(f) \leq \operatorname{cap}(A, B)$}.
         \end{theorem}\pause
	
\ccm{\em Proof.}
\ccb{	
$$
\begin{aligned}
\operatorname{val}(f) &=\sum_{e \text { out of } A} f(e)-\sum_{\text {e  in to } A} f(e) \\
& \leq \sum_{\text { e out of } A} f(e) \\
& \leq \sum_{e \text { out of } A} c(e) \\
&=\operatorname{cap}(A, B)
 \end{aligned}
$$}
		\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p30}}
	}
	%%
	%%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%31
	%
	\frame{
		\frametitle{Certificate of optimality}
	\begin{corollary}
		Let \ccb{$f$} be a flow and let \ccb{$(A,B)$} be any cut.
		If \ccb{$val(f)=\operatorname{cap}(A, B)$}, then \ccb{$f$} is a max flow and \ccb{$(A,B)$} is a min cut.
	\end{corollary}\pause
	
	\ccm{\em Proof.}\vspace{-2mm}
%\hspace{3.5cm}	$ \color{red}\begin{array}{l}	
%		\text{\tiny weak duality}\\[-1mm]
%			\swarrow
%	\end{array} $
	\begin{itemize}
		\vspace{-3mm}
		\item For any flow \ccb{$f^{\prime} : \quad {val}\left(f^{\prime}\right) \leq 	\operatorname{cap}(A, B)=val(f)$}.
		\item For any cut \ccb{$\left(A^{\prime}, B^{\prime}\right) : \operatorname{cap}\left(A^{\prime}, B^{\prime}\right) \geq {val}(f)=\operatorname{cap}(A, B)$}
	\end{itemize}	
%\vspace{-3mm}
%\hspace{5.5cm}	$ \color{red}\begin{array}{l}	
%\nwarrow\\[-2mm]
%	\text{\tiny weak duality}
%	\end{array} $
	
		\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p31}}
	
	}
	%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%32
	%
	\frame{
		\frametitle{Max-flow min-cut theorem}

	\begin{block}{Max-Flow Min-Cut Theorem}	Value of a max flow = capacity of a min cut.
     \end{block}
		
	\vspace{6mm}\centerline{\includegraphics[width=\textwidth]{figures/p32}}
	}
	%%
	%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%33
		\frame{
		\frametitle{Max-flow min-cut theorem}
		\begin{block}{Max-Flow Min-Cut Theorem}	Value of a max flow = capacity of a min cut.
     \end{block}\pause

		\begin{block}{Augmenting path theorem} A flow \ccb{$f$} is a max flow iff no augmenting paths.
        \end{block}\pause
        	
		\ccm{\em Proof.}  The following three conditions are equivalent for any flow \ccb{$f$}:\vspace{-3mm}\pause
		\begin{enumerate}[i.]
			\item There exists a cut \ccb{$(A, B)$} such that \ccb{$\operatorname{cap}(A, B)=val(f)$}.
			\item  \ccb{$f$} is a max flow.
			\item  There is no augmenting path with respect to \ccb{$f$}.
%$	 \color{red}\leftarrow\begin{array}{l}
%			\text{\tiny if Ford–Fulkerson terminates,}\\[-2mm]
%			\quad\text{\tiny (then $f$ is max flow)}
%			\end{array} $
		\end{enumerate}\pause

		\ccc{[i$\Rightarrow$ ii]}\pause \hspace{2em}	This is the weak duality corollary.
			
	}
	
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%34
	\frame{
	\frametitle{Max-flow min-cut theorem}
		\begin{block}{Max-Flow Min-Cut Theorem}	Value of a max flow = capacity of a min cut.
     \end{block}
		\begin{block}{Augmenting path theorem} A flow \ccb{$f$} is a max flow iff no augmenting paths.
        \end{block}
        	
		\ccm{\em Proof.}  The following three conditions are equivalent for any flow \ccb{$f$}:\vspace{-3mm}
		\begin{enumerate}[i.]
			\item There exists a cut \ccb{$(A, B)$} such that \ccb{$\operatorname{cap}(A, B)=val(f)$}.
			\item  \ccb{$f$} is a max flow.
			\item  There is no augmenting path with respect to \ccb{$f$}.
%$	 \color{red}\leftarrow\begin{array}{l}
%			\text{\tiny if Ford–Fulkerson terminates,}\\[-2mm]
%			\quad\text{\tiny (then $f$ is max flow)}
%			\end{array} $
		\end{enumerate}

	\ccc{[ii$\Rightarrow$ iii]}	 \pause\hspace{2em} We prove contrapositive: \ccov{$\lnot$ iii $\Rightarrow \lnot $ii}.\\ \pause
	\begin{itemize}
		\item  Suppose that there is an augmenting path with respect to \ccb{$f$}.
		\item Can improve flow \ccb{$f$} by sending flow along this path.
		\item Thus, \ccb{$f$} is not a max flow.
	\end{itemize}
	
	
}
	%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%35
	\frame{
		\frametitle{Max-flow min-cut theorem}
		\ccc{[ iii $\Rightarrow$ i ]}\vspace{-1em}
		\begin{itemize}
			\item Let \ccb{$f$} be a flow with no augmenting paths.
			\item Let \ccb{$A$} be set of nodes reachable from \ccb{$s$} in residual network \ccb{$G_f$}.
			\item By definition of \ccb{$A: s \in A$}.
			\item By definition of flow \ccb{$f: t \notin A$}.
		\end{itemize}
		
		\begin{columns}
			\begin{column}{6cm}
			\ccb{$$
			\begin{aligned}
			{val}(f) &=\sum_{e \text { out of } A} f(e)-\sum_{\text {e  in to } A} f(e) \\
			%\color{red}\begin{array}{l}
%			\hspace{5mm}\nearrow\\
%			\text{\tiny flow value}\\[-2mm]
%			\hspace{2mm}\text{\tiny lemma}
%			\end{array}
          & = \sum_{\text { e out of } A} c(e)  -  0 \\
			&=\operatorname{cap}(A, B)
			\end{aligned}
			$$}
			\end{column}
		\begin{column}{6cm}
				\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p35}}     			
		\end{column}
		\end{columns}
	}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%36
	
    \section{MeLU: MAML for Cold-Start Recommendation}
	
%%//////////////////////////////////////////////////////////////////////////////////////////////%%37
	%%
	%%
	\frame{
		\frametitle{Analysis of Ford–Fulkerson algorithm (when capacities are integral)}

		\ccp{Assumption.} Every edge capacity \ccb{$c(e)$} is an integer between \ccb{$1$} and \ccb{$C$}.\pause
		
		\ccp{Integrality invariant.} Throughout Ford-Fulkerson, every edge flow \ccb{$f(e)$} and residual capacity \ccb{$c_f (e)$} is an integer.\pause

		\ccm{\em Proof.}  By induction on the number of augmenting paths.\pause

%%	\vspace{-2mm}	
%			
%	\hspace{6cm}	$ \color{red}\begin{array}{l}	
%		\quad\text{\tiny  consider cut A =\{ s \}}\\[-2mm]
%		\text{\tiny (assumes no parallel edges)
%			}\\[-2mm]
%	\hspace{1cm} \swarrow
%		\end{array} $\vspace{-7mm}

		\begin{theorem}
		Ford–Fulkerson terminates after at most \ccb{$val\left(f^{*}\right) \leq n C$}\\
		augmenting paths, where \ccb{$f^*$} is a max flow.
		\end{theorem}\pause

	\ccm{\em Proof.} Each augmentation increases the value of the flow by at least 1.
	
	}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%37

	\frame{
		\frametitle{Analysis of Ford–Fulkerson algorithm (when capacities are integral)}
    \begin{corollary}
	The running time of Ford–Fulkerson is \ccb{$O(m n C)$}.
		\end{corollary}	\pause

   \ccm{\em Proof.} Can use either BFS or DFS to find an augmenting path in \ccb{$O(m)$} time.\pause
	
%\hspace{4cm}	$ \color{red}\begin{array}{l}
%	\quad\text{\tiny $f (e)$ is an integer for every $e$}\\
%\hspace{1.5cm}\swarrow
%	\end{array} $
%	\vspace{-2mm}
	
	\begin{block}{Integrality Theorem} There exists an integral max flow \ccb{$f^*$}
    \end{block}\pause

	\ccm{\em Proof.}
     Since Ford–Fulkerson terminates, theorem follows from integrality invariant.

	}
	%%
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%38
	
	\frame{
		\frametitle{Ford–Fulkerson: exponential example}
	\ccr{Q.} Is generic Ford–Fulkerson algorithm poly-time in input size?\pause
%	\hspace{6.8cm}\ccr{ $ \begin{array}{l}
%		\qquad\nearrow\\[-2mm]
%		\tiny\text{$ m,n $ and $ \log C $}
%		\end{array} $}	
%		\vspace{-3mm}
		
      \ccc{A.} No. If max capacity is \ccb{$C$}, then algorithm can take \ccb{$\geq C$} iterations.\pause

      \bigskip

      \begin{columns}
      	\begin{column}{4cm}
            \begin{itemize}\color{blue}
      	\item $s \rightarrow v \rightarrow w \rightarrow t$\
      	\item $s \rightarrow w \rightarrow v \rightarrow t$
      	\item $s \rightarrow v \rightarrow w \rightarrow t$
      	\item $s \rightarrow w \rightarrow v \rightarrow t$
      	\item $\dots$
      	\item $s \rightarrow v \rightarrow w \rightarrow t$
      	\item $s \rightarrow w \rightarrow v \rightarrow t$
      \end{itemize}
      		
      	\end{column}
      	\begin{column}{6cm}
      	\centerline{\includegraphics[width=\textwidth]{figures/p38}}
      	\end{column}
      \end{columns}
	}

	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%39

	\frame{
		\frametitle{Network flow: quiz 4}
		The Ford–Fulkerson algorithm is guaranteed to terminate if the edge capacities are $\ldots$
	\begin{enumerate}[A.]
		\item Rational numbers.
		\item Real numbers.
		\item Both A and B.
		\item Neither A nor B.
	\end{enumerate}
	}
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%40
	
	\frame{
		\frametitle{Choosing good augmenting paths}
	\ccp{Use care when selecting augmenting paths.}	\vspace{-3mm}
	\begin{itemize}
		\item Some choices lead to exponential algorithms.
		\item Clever choices lead to polynomial algorithms.
	\end{itemize}\pause\bigskip

\ccp{Pathology.} When edge capacities can be irrational, no guarantee that Ford–Fulkerson terminates (or converges to a maximum flow)!
\pause\bigskip
		
\cco{Goal.}	Choose augmenting paths so that:\vspace{-3mm}
\begin{itemize}
	\item Can find augmenting paths efficiently.
	\item Few iterations.
\end{itemize}
		
	}
	
		%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%41
	
	\frame{
		\frametitle{Choosing good augmenting paths}
		\cco{Choose augmenting paths with:}	\vspace{-3mm}\pause
		\begin{itemize}
			\item Max bottleneck capacity(``fattest''). \pause
			\item Sufficiently large bottleneck capacity.\pause
			\item Fewest edges.
		\end{itemize}
		
	\centerline{\includegraphics[width=\textwidth,height=5cm]{figures/p41}}
	}
	
		%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%42

    \frame{
	\frametitle{Capacity-scaling algorithm}
	\cco{Overview.}	 Choosing augmented paths with \ccp{large} bottleneck capacity.\pause
	\begin{itemize}
		\item Maintain scaling parameter \ccb{$\Delta$}.\pause
		\item Let \ccb{$G_f(\Delta)$} be the part of the residual network containing
		only those edges with capacity \ccb{$\geq \Delta$}.\pause
		\item Any augmenting path in \ccb{$G_f(\Delta)$} has bottleneck capacity \ccb{$\geq \Delta$}.
	\end{itemize}
	
	\bigskip\centerline{\includegraphics[width=0.8\textwidth]{figures/p42}}
}
	
	
	
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%43
	\frame{
		\frametitle{Capacity-scaling algorithm}\vspace{5mm}

\begin{exampleblock}{}
    \begin{algorithm}[H]
        \SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
        \SetKwFunction{CS}{\sc Capacity-Scaling}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
        \SetKwFunction{Up}{\sc Update}\SetKwFunction{Au}{\sc Augment}
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
     \CS{$G$}
     \BlankLine
     \For{each edge $e \in E$}{$f(e)\leftarrow 0$}
     $\Delta \leftarrow$ largest power of $2\leq C$\;
	 \While{$\Delta\geq 1$}{
      $G_{f}(\Delta) \leftarrow \Delta$-residual network of $G$ with respect to flow $f$\;
      \While{there exists an $s\rightsquigarrow t$ path $P$ in $G_f (\Delta)$}{
         $f \leftarrow$ \Au{$f$, $c$, $P$}\;
         \Up{$G_\Delta(f)$}\;
         }
       $\Delta=\Delta/2$\;
      }
      \Return $f$\;
     \end{algorithm}
     \end{exampleblock}

	}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%44
	\frame{
		\frametitle{Capacity-scaling algorithm: proof of correctness}
		\ccc{Assumption.} All edge capacities are integers between \ccb{$1$} and \ccb{$C$}.\pause\bigskip
	
	
        \cco{Invariant.} The scaling parameter \ccb{$\Delta$} is a power of \ccb{$2$}.\pause

        \ccm{\em Proof.} Initially a power of \ccb{$2$}; each phase divides \ccb{$\Delta$} by exactly \ccb{$2$}.\pause\bigskip
	
	    \cco{Integrality invariant.} Throughout the algorithm, every edge flow \ccb{$f(e)$} and residual capacity \ccb{$c_f (e)$} is an integer. \pause

        \ccm{\em Proof.}  Same as for generic Ford–Fulkerson.

        }

 %%%%//////////////////////////////////////////////////////////////////////////////////////////////%%44

        	\frame{
		\frametitle{Capacity-scaling algorithm: proof of correctness}

	
    \begin{theorem}
        If capacity-scaling algorithm terminates, then \ccb{$f$} is a max flow.
    \end{theorem}\pause
    	
	\ccm{\em Proof.}\pause
		\begin{itemize}
			\item By integrality invariant, when \ccb{$\Delta=1$} \ccc{$\Rightarrow$} \ccb{$G_{f}(\Delta)=G_{f}$}
			\item Upon termination of \ccb{$\Delta=1$} phase, there are no augmenting paths.
			\item Result follows augmenting path theorem.
		\end{itemize}
		
	}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

	\frame{
		\frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{block}{Lemma 1}
		 There are \ccb{$1+\left\lfloor\log _{2} C\right\rfloor$} scaling phases.	
	\end{block}

%\ccm{\em Proof.} Initially \ccb{$C / 2<\Delta \leq C$}; \ccb{$\Delta$} decreases by a factor of 2 in each iteration.

\begin{block}{Lemma 2}
There are \ccb{$\leq 2m$} augmentations per scaling phase.
\end{block}

\begin{block}{Lemma 3}
	Let \ccb{$f$} be the flow at the end of a \ccb{$\Delta$}-scaling phase.\\
	Then, the max-flow value \ccb{$\leq \operatorname{val}(f)+m \Delta$}.
\end{block}
%\ccm{\em Proof.} Next slide.\pause


}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

	\frame{
		\frametitle{Capacity-scaling algorithm: analysis of running time}

\begin{theorem}
	The capacity-scaling algorithm takes \ccb{$O(m^2 log C)$} time.
\end{theorem}	\pause
\ccm{\em Proof.}\vspace{-2mm}\pause
\begin{itemize}
	\item Lemma 1+ Lemma 2 \ccc{$\Rightarrow$} \ccb{$O(m \log C)$} augmentations.
	\item Finding an augmenting path takes \ccb{$O(m)$} time.
\end{itemize}	

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

    \frame{
	 \frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{block}{Lemma 1}
		 There are \ccb{$1+\left\lfloor\log _{2} C\right\rfloor$} scaling phases.	
	\end{block}\pause

   \ccm{\em Proof.} Initially \ccb{$C / 2<\Delta \leq C$}; \ccb{$\Delta$} decreases by a factor of 2 in each iteration.

}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45


    \frame{
	 \frametitle{Capacity-scaling algorithm: analysis of running time}

    \begin{block}{Lemma 2}
    There are \ccb{$\leq 2m$} augmentations per scaling phase.
    \end{block}\pause

    \ccm{\em Proof.} %\hspace{7cm}\ccr{ $ \begin{array}{l}
%	\quad\tiny\text{or equivalently}\\[-2mm]
%	\quad~\tiny\text{at the end}\\[-2mm]
%	\tiny\text{of a 2$\Delta$-scaling phase}\\
%	\qquad\swarrow\\
%	\end{array} $}\vspace{-6mm}
    \begin{itemize}
	\item Let \ccb{$f$} be the flow at the beginning of a $\Delta$-scaling phase.
	\item Lemma 3 \ccc{$\Rightarrow$} max-flow value  \ccb{$\leq {val}(f)+m(2 \Delta)$}.
	\item Each augmentation in a $\Delta$-phase increases \ccb{$val(f)$} by at least \ccb{$\Delta$}.
	
\end{itemize}
	
	}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%46
	
	\frame{
		\frametitle{Capacity-scaling algorithm: analysis of running time}
    \begin{block}{Lemma 3}
	Let \ccb{$f$} be the flow at the end of a \ccb{$\Delta$}-scaling phase.\\
	Then, the max-flow value \ccb{$\leq \operatorname{val}(f)+m \Delta$}.
\end{block}\pause

    \ccm{\em Proof.} \vspace{-4mm}\pause
		\begin{itemize}
			\item We show there exists a cut \ccb{$(A, B)$} such that \ccb{$cap(A, B)\leq val(f) + m \Delta$}.
			\item Choose \ccb{$A$} to be the set of nodes reachable from \ccb{$s$} in \ccb{$G_f (\Delta)$}.
			\item By definition of \ccb{$A: s \in A$}.
			\item By definition of flow \ccb{$f: t \notin A$}.
		\end{itemize}
	\bigskip\pause

	\begin{columns}
	\hspace{2mm}	\begin{column}{6cm}
	\ccb{$\begin{array}{ll}
	val(f)&=\sum\limits_{e \text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)\\
	%\ccr{ \begin{array}{l}
%			~~\nearrow\\[-2mm]
%			\tiny\text{flow}\\[-2mm]
%			\tiny\text{value}\\[-2mm]			
%			\tiny\text{lemma}
%		\end{array} }
	  &\geq \sum\limits_{e \text { out of } A}(c(e)-\Delta)-\sum\limits_{\text { e in to } A} \Delta\\
	  &\geq \sum\limits_{e \text { out of } A} c(e)-\sum\limits_{e \text { out of } A} \Delta-\sum\limits_{e \text { in to } A} \Delta \\
	   &\geq \operatorname{cap}(A, B)-m \Delta
	   \end{array}$}
		\end{column}
	
	\begin{column}{5cm}
	\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p46}}
	\end{column}
	\end{columns}	
		
	}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

	\section{More about meta-learning and MAML}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%48
	%%
	\frame{
		\frametitle{Shortest augmenting path}
		\ccr{Q.} How to choose next augmenting path in Ford–Fulkerson? \pause

		\ccc{A.}  Pick one that uses the \ccp{fewest} edges.\pause


\begin{exampleblock}{}
    \begin{algorithm}[H]
        \SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
        \SetKwFunction{CS}{\sc Shortest-Augmenting-Path}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
        \SetKwFunction{Up}{\sc Update}\SetKwFunction{Au}{\sc Augment}\SetKwFunction{BFS}{\sc BFS}
        \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
     \CS{$G$}
     \BlankLine
     \For{each edge $e \in E$}{$f(e)\leftarrow 0$}
     $G_f\leftarrow$ residual network of $G$ with respect to flow $f$\;
	 \While{there exists an $s\rightsquigarrow t$ path in $G_f$}{
      $P\leftarrow$ \BFS{$(G_f)$}\;
      $f \leftarrow$ \Au{$f$, $c$, $P$}\;
      \Up{$G_f$}\;
       }
      \Return $f$\;
     \end{algorithm}
     \end{exampleblock}


	}
	
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%49
	\frame{
		\frametitle{Shortest augmenting path: overview of analysis}
	
	\begin{block}{Lemma 1}
		The length of a shortest augmenting path never decreases.
	\end{block}\pause

    \begin{block}{Lemma 2}
    After at most \ccb{$m$} shortest-path augmentations, the length of a shortest augmenting path strictly increases.
    \end{block}\pause

    \begin{theorem}
    The shortest-augmenting-path algorithm takes \ccb{$O(m^2 n)$} time.
    \end{theorem}\pause

    \ccm{\em Proof.}\pause
\begin{itemize}
	\item \ccb{$O(m)$} time to find a shortest augmenting path via BFS.\pause
	\item There are \ccb{$\leq mn$} augmentations\pause
	\begin{enumerate}[-]
		\item at most \ccb{$m$} augmenting paths of length \ccb{$k$} \pause \ccpk{$\longleftarrow$ Lemma 1 + Lemma 2 }
		\item at most \ccb{$n-1$} different lengths
	\end{enumerate}
\end{itemize}
	}
%%//////////////////////////////////////////////////////////////////////////////////////////////%%50
%	
	\frame{
		\frametitle{Shortest augmenting path: analysis}
    \begin{definition}
        Given a \ccp{digraph} \ccb{$G = (V, E)$} with source \ccb{$s$}, its \ccp{level graph} is defined by:
        \vspace{-4mm}
\begin{itemize}
	\item \ccb{$\ell(v)$ = number of edges in shortest $s\rightsquigarrow v$ path}.
	\item \ccb{$L_G = (V,E_G)$} is the subgraph of \ccb{$G$} that contains only those edges \ccb{$(v, w) \in E$}
	with  \ccb{$\ell(w) = \ell(v) + 1$}.
\end{itemize}
\end{definition}	
\vspace{3mm}\centerline{\includegraphics[width=0.7\textwidth]{figures/p50}}
	}
%%//////////////////////////////////////////////////////////////////////////////////////////////%%51
\frame{
	\frametitle{Network flow: quiz 5}
	Which edges are in the level graph of the following digraph?
	\begin{enumerate}[A.]
		\item \ccb{$D\rightarrow F$}
		\item \ccb{$E\rightarrow F$}
		\item  Both A and B.
		\item Neither A nor B.
	\end{enumerate}
	
	\vspace{1cm}\centerline{\includegraphics[width=\textwidth]{figures/p51}}
	
}


%%//////////////////////////////////////////////////////////////////////////////////////////////%%52


\frame{
	\frametitle{Shortest augmenting path: analysis}
	\begin{definition}
        Given a \ccp{digraph} \ccb{$G = (V, E)$} with source \ccb{$s$}, its \ccp{level graph} is defined by:
        \vspace{-4mm}
\begin{itemize}
	\item \ccb{$\ell(v)$ = number of edges in shortest $s\rightsquigarrow v$ path}.
	\item \ccb{$L_G = (V,E_G)$} is the subgraph of \ccb{$G$} that contains only those edges \ccb{$(v, w) \in E$}
	with  \ccb{$\ell(w) = \ell(v) + 1$}.
\end{itemize}
\end{definition}

\cco{Key property.} \ccb{$P$} is a shortest \ccb{$s\rightsquigarrow v$} path in \ccb{$G$} iff \ccb{$P$}  is an \ccb{$s\rightsquigarrow v$}  path in \ccb{$L_G$}.
	
	\vspace{1cm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p52}}
}


	
	%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%53
	%%
	\frame{
		\frametitle{Shortest augmenting path: analysis}
	\begin{block}{Lemma 1}
		The length of a shortest augmenting path never decreases.
	\end{block}\pause\vspace{-1em}

     \ccm{\em Proof.}\pause\vspace{-1em}
	\begin{itemize}
		\item Let \ccb{$f$} and \ccb{$f'$}  be flow before and after a shortest-path augmentation.
		\item  Let \ccb{$L_G$} and \ccb{$L_{G'}$} be level graphs of \ccb{$G_f$} and \ccb{$G_{f'}$}.
		\item Only back edges added to \ccb{$G_{f'}$} \\
		(any \ccb{$s\rightsquigarrow t$} path that uses a back edge is longer than previous length)
	\end{itemize}

    \centerline{\includegraphics[width=0.6\textwidth]{figures/p53}}     	
	}
	%%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%54
	%%%
	\frame{
		\frametitle{Shortest augmenting path: analysis}
	    \begin{block}{Lemma 2}
    After at most \ccb{$m$} shortest-path augmentations, the length of a shortest augmenting path strictly increases.
    \end{block}\pause\vspace{-1em}
     \ccm{\em Proof.}\pause\vspace{-1em}
	\begin{itemize}
	\item  At least one (bottleneck) edge is deleted from \ccb{$L_G$} per augmentation.
	\item No new edge added to \ccb{$L_G$} until shortest path length strictly increases.
		\end{itemize}
		
		\vspace{3mm}\centerline{\includegraphics[width=.65\textwidth]{figures/p54}}
		
	}
	

	
	
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%55
	\frame{
		\frametitle{Shortest augmenting path: review of analysis}
	\begin{block}{Lemma 1}
		The length of a shortest augmenting path never decreases.
	\end{block}

    \begin{block}{Lemma 2}
    After at most \ccb{$m$} shortest-path augmentations, the length of a shortest augmenting path strictly increases.
    \end{block}

    \begin{theorem}
    The shortest-augmenting-path algorithm takes \ccb{$O(m^2 n)$} time.
    \end{theorem}
   	
	}
	
	%%//////////////////////////////////////////////////////////////////////////////////////////////%%56
	
	\frame{
		\frametitle{Shortest augmenting path: improving the running time}
		
		
		\cco{Note.}  \ccb{$\Theta(m n)$} augmentations necessary for some flow networks.
		\pause\hspace{-2em}
		\begin{itemize}
			\item Try to decrease time per augmentation instead.
			\item Simple idea \ccc{$\Rightarrow$} \ccb{$\ccb{O(mn^2)}$}   \hspace{2em }[\ccc{Dinitz 1970}]\pause
			\item Dynamic trees \ccc{$\Rightarrow$} \ccb{$O(m n \log n)$}   \hspace{2em}  [\ccc{Sleator–Tarjan 1983}]
		\end{itemize}
	\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth,height=5cm]{figures/p56}}
	}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%58
\end{document}