\documentclass[9pt]{beamer}

%\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm2e}
\usepackage{color, colortbl}
\usepackage{enumerate}
\usepackage{arydshln}
\usepackage{multirow}

\renewcommand{\figurename}{Fig}
\usetheme{uha}



%\theoremstyle{plain}
%  \newtheorem{theorem}{Theorem}
%  \newtheorem{lemma}{Lemma}
\newtheorem{corrolary}{Corollary}
\newtheorem{claim}{Claim}
\newtheorem{proposition}{Proposition}
\newtheorem{property}{Property}
%  \newtheorem{fact}{Fact}
%\theoremstyle{definition}
%  \newtheorem{definition}{Definition}
%  \newtheorem{example}{Example}
%\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{proviso}{Proviso}


\newcommand{\ccr}[1]{{\color{red}#1}}
\newcommand{\ccb}[1]{{\color{blue}#1}}
\newcommand{\ccp}[1]{{\color{purple}#1}}
\newcommand{\ccm}[1]{{\color{magenta}#1}}
\newcommand{\cco}[1]{{\color{orange}#1}}
\newcommand{\ccy}[1]{{\color{yellow}#1}}
\newcommand{\ccl}[1]{{\color{lime}#1}}
\newcommand{\ccc}[1]{{\color{cyan}#1}}
\newcommand{\ccg}[1]{{\color{gray}#1}}
\newcommand{\ccpk}[1]{{\color{pink}#1}}
\newcommand{\ccov}[1]{{\color{olive}#1}}



\begin{document}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%1

\title{Model-Agnostic Meta-Learning (MAML) }
\subtitle{A Meta-Learning approach for Fast Adaptation of Deep Networks}
\author{Yuyang Huang, Xuyang Zhao}
\institute{School of Software, Shanghai Jiao Tong University}
\date{\hspace{2em}}
\frame{
	\titlepage
}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%1

\section{Introduction}


%%//////////////////////////////////////////////////////////////////////////////////////////////%%3
\frame{
	\frametitle{Introduction: Meta-Learning}

	Meta learning = Learning to learn

	* \ccr{Meta} + X $\longrightarrow$ X about X

	\centerline{\includegraphics[width=1.0\textwidth]{figs/meta-ml.png}}
}
\frame{
	\frametitle{Introduction: Meta-Learning Background}
	\textbf{A meta-learning model}
	\begin{itemize}
		\item learns from \ccb{past learning experience}
		\item can learn \ccb{future tasks} \ccr{better} based on prior knowledge
		\item learns the learning function during the learning process
	\end{itemize}

	\textbf{Metrics for meta-learning}
	\begin{itemize}
		\item size of training-set for model convergence
		\item robustness of model
		\item accuracy of the prediction
		\item etc...
	\end{itemize}

}
%//////////////////////////////////////////////////////////////////////////////////////////////%%4
\frame{
	\frametitle{Introduction: Few-shot Learning problem}

	\begin{definition}
		An \ccp{$st$-cut (cut)} is a partition \ccb{$(A, B)$} of the nodes with \ccb{$s\in A$} and \ccb{$t \in B$}.
	\end{definition}\pause

	\begin{definition}
		Its \ccp{capacity} is the sum of the capacities of the edges from \ccb{$A$} to \ccb{$B$}.
		\ccb{\[
				\operatorname{cap}(A, B)=\sum_{e \text { out of } A} c(e)
			\]}\vspace{-1em}
	\end{definition}\pause\bigskip


	\centerline{\includegraphics[width=0.65\textwidth]{figures/p4}}
}
%%%//////////////////////////////////////////////////////////////////////////////////////////////%%5
\frame{
	\frametitle{Minimum-cut problem}
	\begin{definition}
		An \ccp{$st$-cut (cut)} is a partition \ccb{$(A, B)$} of the nodes with \ccb{$s\in A$} and \ccb{$t \in B$}.
	\end{definition}

	\begin{definition}
		Its \ccp{capacity} is the sum of the capacities of the edges from \ccb{$A$} to \ccb{$B$}.
		\ccb{\[
				\operatorname{cap}(A, B)=\sum_{e \text { out of } A} c(e)
			\]}\vspace{-1em}
	\end{definition}\bigskip

	\centerline{\includegraphics[width=0.7\textwidth]{figures/p5}}
}
%%//////////////////////////////////////////////////////////////////////////////////////////////%%6

\frame{
	\frametitle{Few-shot Learning problem}

	\cco{Min-cut problem.} Find a cut of minimum capacity.\bigskip\bigskip

	\centerline{\includegraphics[width=0.6\textwidth]{figures/p6}}
}


%%//////////////////////////////////////////////////////////////////////////////////////////////%%7
\frame{
	\frametitle{Few shot learning cases: Omniglot}
	Omniglot : Few-shot Classification
	\begin{enumerate}[\color{blue} A.]
		\item $11~ (20+25 - 8 - 11 - 9 - 6)$
		\item $34 ~(8+11+9+6)$
		\item $45~ (20+ 25)$
		\item $79~	(20+ 25+ 8+ 11+ 9+ 6)$
	\end{enumerate}
	\vspace{5mm}

	\centerline{\includegraphics[width=0.8\textwidth]{figures/p7}}

}



%%//////////////////////////////////////////////////////////////////////////////////////////////%%8
\frame{
	\frametitle{Maximum-flow problem}
	\begin{definition}
		An \ccp{$st$-flow(flow)} \ccb{$f$} is a function that satisfies:
		\begin{itemize}
			\item For each \ccb{$e\in E$}: \hspace{2mm}  \ccb{$0 \leq f(e) \leq c(e)$}
			\item For each \ccb{$v\in V-\{s,t\}$}:  \ccb{$\sum\limits_{e \text { in to } v} f(e) \  =\sum\limits_{e \text { out of } v} f(e)$}
		\end{itemize}
	\end{definition}
	\bigskip

	\centerline{\includegraphics[width=0.8\textwidth]{figures/p8}}
}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%9
\frame{
	\frametitle{Maximum-flow problem}
	\begin{definition}
		An \ccp{$st$-flow(flow)} \ccb{$f$} is a function that satisfies:
		\begin{itemize}
			\item For each \ccb{$e\in E$}: \hspace{2mm}  \ccb{$0 \leq f(e) \leq c(e)$}
			\item For each \ccb{$v\in V-\{s,t\}$}:  \ccb{$\sum\limits_{e \text { in to } v} f(e) \  =\sum\limits_{e \text { out of } v} f(e)$}
		\end{itemize}
	\end{definition}
	\begin{definition}
		The \ccp{value}	of a flow \ccb{$f$} is: \ccb{$val(f)=\sum\limits_{e \text { out of } s} f(e)-\sum\limits_{e \text { in to } s} f(e)$}
	\end{definition}\smallskip

	\centerline{\includegraphics[width=0.7\textwidth]{figures/p9}}
}


%%////////////////////////////////////////////////////////////////////////////////////////////%%10
\frame{
	\frametitle{Maximum-flow problem}

	\cco{Max-flow problem.} Find a flow of maximum value.\bigskip\bigskip


	\centerline{\includegraphics[width=0.7\textwidth]{figures/p10}}
}


\section{Problem description}
%
%%//////////////////////////////////////////////////////////////////////////////////////////////%%12
\frame{
	\frametitle{Start with Machine learning}
	\ccp{ Conventional supervised machine learning}
	\vspace{-2mm}
	\begin{itemize}
		\item  dataset  \ccb{$\mathcal{D} = {(x_1, y_1), . . . ,(x_N , y_N )}$} is given.
		\item \ccb{$(x_i, y_i)$}: pair of input data and output classification or regression result, such as (input image, output label).
		\item Predictive model: $\hat{y}=f_\theta(x)$, trained by $\theta^*=\arg \min_\theta \mathcal{L}(\mathcal{D};\theta,\omega)$.
	\end{itemize}\vspace{5mm}
	\centerline{\includegraphics[width=0.1\textwidth]{figs/ml.png} $f($ \includegraphics[width=0.2\textwidth]{figs/cat1.png} $) = ``cat"$}
}
%
%%//////////////////////////////////////////////////////////////////////////////////////////////%%13

\frame{
	\frametitle{Problem triggered}
	\ccp{No enough dataset?}
	\vspace{-2mm}
	\begin{itemize}
		\item When there are enough samples for dataset $\mathcal{T}$, we can achieve ideal result. However, this may be difficult or even not possible.
		\item What if Alphago hadn't played Go for many times?
		\item How does Taobao recommend items to new user?
	\end{itemize}\vspace{3mm}
	\centerline{\includegraphics[width=0.3\textwidth]{figs/alphago.png} \includegraphics[width=0.2\textwidth]{figs/taobao.jpeg}}
	\vspace{-2mm}
	\begin{definition}
		\ccp{Few-shot learning} is the problem of making predictions based on a limited number of samples.
		\begin{itemize}
			\ccg{
			\item Few-shot classification: image classification, short text sentiment classification, and object recognition.
			\item Few-shot regression: cold-start recommendation.}
		\end{itemize}
	\end{definition}
}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%14
%
\frame{
	\frametitle{Meta learning}
	\vspace{-2mm}
	\ccp{Humans} vs \ccp{Machine}
	\begin{columns}
		\begin{column}{5cm}
			\begin{itemize}
				\item Children who have only seen trees and flowers a few times can distinguish them quickly.
				\item People able to ride a bike will most likely find a way to ride a motorcycle fast with little or even no demonstration.
			\end{itemize}
		\end{column}
		\begin{column}{5cm}
			\begin{itemize}
				\item  Inspired by human behaviors, The idea of meta learning is to design a model with an adaption process which happens during test but is exposed to the new task configurations properly.
			\end{itemize}
		\end{column}
	\end{columns}\vspace{5mm}
	\ccb{Solution}
	\vspace{-2mm}
	\begin{itemize}
		\item  learn from scratch $\rightarrow$  learn from a distribution of tasks $\mathcal{T}\sim p(\mathcal{T})$.
		\item algorithm function with $\omega$ pre-specified $  \rightarrow $ learn the learning algorithm.
		\item \ccb{learning to learn.}
	\end{itemize}\vspace{5mm}
}
%%%//////////////////////////////////////////////////////////////////////////////////////////////%%15

\frame{
	\frametitle{Meta learning}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{	\item Start with $f (e) = 0$ for each edge $e \in E$.
		\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.
		\item Augment flow along path $P$.}
		\item Humans, in contrast, learn new concepts and skills faster and more effectively.
		      Children who have only seen trees and flowers a few times can distinguish them quickly. People able to
		      ride a bike will most likely find a way to ride a motorcycle fast with little or even no demonstration
	\end{itemize}\vspace{3mm}

	\centerline{\includegraphics[width=\textwidth]{figures/p15}}
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%16
\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\ccg{\item Start with $f (e) = 0$ for each edge $e \in E$.
		\item Find an $s\rightsquigarrow t$ path $P$ where each edge has $f (e) < c(e)$.
		\item Augment flow along path $P$.}
		\item  Repeat until you get stuck.
	\end{itemize}\vspace{5mm}


	\centerline{\includegraphics[width=\textwidth]{figures/p16}}
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%17
\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
		\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$} where each edge has \ccb{$f (e) < c(e)$}.
		\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
	\end{itemize}
	\bigskip


	\centerline{\includegraphics[width=\textwidth]{figures/p17}}
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%18

\frame{
	\frametitle{Toward a max-flow algorithm}
	\ccp{Greedy algorithm.}
	\vspace{-4mm}
	\begin{itemize}
		\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
		\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$} where each edge has \ccb{$f (e) < c(e)$}.
		\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
	\end{itemize}
	\bigskip

	\centerline{\includegraphics[width=\textwidth]{figures/p18}}
}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%19

\frame{
	\frametitle{Why the greedy algorithm fails}
	\ccr{Q.} Why does the greedy algorithm fail?\pause

	\ccc{A.} Once greedy algorithm increases flow on an edge, it never decreases it.
	\pause\smallskip

	\cco{Ex.} Consider flow network \ccb{$G$}.	\vspace{-3mm}
	\begin{itemize}
		\item The unique max flow has \ccb{$f^*(v,w)=0$}.
		\item Greedy algorithm could choose \ccb{$s\rightarrow v\rightarrow w \rightarrow t$} as first augmenting path.
	\end{itemize}\smallskip

	\centerline{\includegraphics[width=0.4\textwidth]{figures/p19}}\pause

	\cco{Bottom line.} Need some mechanism to \ccr{undo} a bad decision.
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%20
\frame{
	\frametitle{Residual network}
	\vspace{2mm}
	\begin{columns}
		\begin{column}{6cm}
			\ccp{Original edge} \ccb{$e=(u,v)\in E$}.
			\begin{itemize}
				\item Flow \ccb{$f(e)$}.
				\item Capacity \ccb{$c(e)$}
			\end{itemize}
			\vspace{3mm}

			\ccp{Reverse edge}  \ccb{$e^{\text { reverse }}=(v, u)$}
			\begin{itemize}
				\item	\cco{Undo} flow sent.
			\end{itemize}

		\end{column}

		\begin{column}{4cm}
			\centerline{\includegraphics[width=\textwidth]{figures/p20}}
		\end{column}
	\end{columns}
	\bigskip\pause
	\begin{columns}

		\begin{column}{6cm}
			\ccp{Residual capacity}
			\ccb{$$
					c_{f}(e)=\left\{\begin{array}{ll}{c(e)-f(e)} & {\text { if } e \in E} \\ {f(e)} & {\text { if } e^{\text { reverse }} \in E}\end{array}\right.
				$$}
		\end{column}

		\begin{column}{4cm}
			\centerline{\includegraphics[width=\textwidth]{figures/p20_2}}
		\end{column}
	\end{columns}


	\ccp{Residual network} \ccb{$G_f=(V,E_f,s,t,c_f)$} 	%$ \color{red}\begin{array}{l}
	%\text{\tiny edges with positive}\\[-2mm]
	%\text{\tiny residual capacity}\\
	%\swarrow\\
	%\end{array} $ 	\vspace{-4mm}
	\begin{itemize}
		\vspace{-4mm}
		\item \ccb{$E_{f}=\{e : f(e)<c(e)\} \cup\left\{e^{\text { reverse }} : f(e)>0\right\}$}.	%$ \color{red}\begin{array}{l}
		      %	\text{\tiny where flow on a reverse edge}\\[-2mm]
		      % \quad	\text{\tiny negates flow on}\\[-2mm]
		      %	\text{\tiny corresponding forward edge}\\
		      %	\swarrow\\
		      %	\end{array} $
		      % \vspace{-2mm}
		\item Key property: \ccb{$f'$} is a flow in \ccb{$G_f$} iff \ccb{$f+f'$} is a flow in \ccb{$G$}
	\end{itemize}
}
%%
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%21

\frame{
	\frametitle{Augmenting path}
	\begin{definition}
		An \ccp{augmenting path} is a simple \ccb{$s\rightsquigarrow t$} path in the residual network \ccb{$G_f$}.
	\end{definition}\pause

	\begin{definition}
		The \ccp{bottleneck capacity} of an augmenting path \ccb{$P$} is the minimum residual capacity of any edge in \ccb{$P$}.
	\end{definition}
}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%21

\frame{
	\frametitle{Augmenting path}

	\cco{Key Property.}
	Let \ccb{$f$} be a flow and let \ccb{$P$} be an augmenting path in \ccb{$G_f$}. After calling \ccb{$f'\leftarrow\mathtt{Augment}(f,c,P)$}, the resulting \ccb{$f'$} is a flow and \ccb{$val(f')=val( f )+bottleneck(G_f, P)$}.\pause

	\begin{exampleblock}{}
		% \scalebox{0.9}{
		\begin{algorithm}[H]
			\SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
			\SetKwFunction{Au}{\sc Augment}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
			\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
			\Au{$f$,$c$,$P$}
			\BlankLine
			$\delta \leftarrow$ bottleneck capacity of augmenting path P\;
			\For{each edge $e\in P$}{
				\lIf{$(e\in E)$}{$f(e)\leftarrow f(e)+\delta$}
				\Else{$f\left(e^{\text { reverse }}\right) \leftarrow f\left(e^{\text { reverse }}\right)-\delta$}
			}
			\Return $f$\;
		\end{algorithm}
	\end{exampleblock}

}
%%
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%22
%
\frame{
	\frametitle{Network flow: quiz 2}
	Which is the augmenting path of highest bottleneck capacity?
	\begin{enumerate}\color{blue}
		\item $A \rightarrow F \rightarrow G \rightarrow H$
		\item $A \rightarrow B \rightarrow C \rightarrow D \rightarrow H$
		\item $A \rightarrow F \rightarrow B \rightarrow G \rightarrow H$
		\item $A \rightarrow F \rightarrow B \rightarrow G \rightarrow C \rightarrow D \rightarrow H$
	\end{enumerate}	\vspace{3mm}
	\centerline{\includegraphics[width=0.8\textwidth]{figures/p22}}
}
%%
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%23
\frame{
	\frametitle{Ford–Fulkerson algorithm}
	\ccp{Ford–Fulkerson augmenting path algorithm.}
	\vspace{-3mm}
	\begin{itemize}
		\item Start with \ccb{$f (e) = 0$} for each edge \ccb{$e \in E$}.
		\item Find an \ccb{$s\rightsquigarrow t$} path \ccb{$P$}  in the residual network \ccb{$G_f$}.
		\item Augment flow along path \ccb{$P$}.
		\item  Repeat until you get stuck.
	\end{itemize}
	\pause

	\begin{exampleblock}{}
		\begin{algorithm}[H]
			\SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
			\SetKwFunction{FF}{\sc Ford–Fulkerson}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
			\SetKwFunction{Up}{\sc Update}\SetKwFunction{Au}{\sc Augment}
			\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
			\FF{$G$}
			\BlankLine
			\For{each edge $e \in E$}{$f(e)\leftarrow 0$}
			$G_f\leftarrow $ residual network of $G$ with respect to flow $f$\;

			\While{there exists an $s\rightsquigarrow t$ path $P$ in $G_f$}{
				$f\leftarrow$ \Au{$f$,$c$,$P$}\;
				\Up{$G_f$}\;
			}
			\Return $f$\;
		\end{algorithm}
	\end{exampleblock}

}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%24

\section{Algorithms}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%25

\frame{
	\frametitle{Relationship between flows and cuts}
	\begin{lemma}
		Let \ccb{$f$} be any flow and let \ccb{$(A,B)$} be any cut. Then, the value of the flow \ccb{$f$} equals the net flow across the cut \ccb{$(A,B)$}.
		\ccb{\begin{equation*}
				v a l(f)=\sum\limits_{\text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)
			\end{equation*}}
	\end{lemma}

	\bigskip
	\centerline{\includegraphics[width=0.8\textwidth]{figures/p25}}
}


%%//////////////////////////////////////////////////////////////////////////////////////////////%%36

\section{MeLU: MAML for Cold-Start Recommendation}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%37
%%
%%
\frame{
	\frametitle{Cold-Start Recommendation problem}

	\ccp{Recommendation.} \\
	Companies use recommendation systems to deliver personalized contents and sell products.

	\begin{columns}
		\begin{column}{8cm}
			\centerline{\includegraphics[width=0.3\textwidth]{figs/tiktok.png}}
		\end{column}
		\begin{column}{4cm}
			\centerline{\includegraphics[width=0.3\textwidth]{figs/taobao.jpeg}}
		\end{column}
	\end{columns}
	\pause

	\ccp{Cold-Start problem.} \\
	Modern recommendation systems use \ccp{Machine Learning} approach to provide \ccp{customized} user-experience.
	Recommendation using ML is hard when \#users and \#items are still small. (\ccr{A Cold-Start}).

	\pause

	\begin{definition}
		\ccm{Few-Shot Learning}
		\begin{itemize}
			\item Few-shot learning is the problem of making predictions based on a limited number of samples.
		\end{itemize}
	\end{definition}
}

%%//////////////////////////////////////////////////////////////////////////////////////////////%%37

\frame{
	\frametitle{MAML for cold-start recommendation}

	\ccr{User Preference Estimator.} the model that estimate users' preference for certain item.
	\centerline{\includegraphics[width=0.6\textwidth]{figs/melu-pref.png}}


	\ccm{\em Proof.} Can use either BFS or DFS to find an augmenting path in \ccb{$O(m)$} time.\pause

	%\hspace{4cm}	$ \color{red}\begin{array}{l}
	%	\quad\text{\tiny $f (e)$ is an integer for every $e$}\\
	%\hspace{1.5cm}\swarrow
	%	\end{array} $
	%	\vspace{-2mm}

	\begin{block}{Integrality Theorem} There exists an integral max flow \ccb{$f^*$}
	\end{block}\pause

	\ccm{\em Proof.}
	Since Ford–Fulkerson terminates, theorem follows from integrality invariant.

}
%%
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%38

\frame{
	\frametitle{Ford–Fulkerson: exponential example}
	\ccr{Q.} Is generic Ford–Fulkerson algorithm poly-time in input size?\pause
	%	\hspace{6.8cm}\ccr{ $ \begin{array}{l}
	%		\qquad\nearrow\\[-2mm]
	%		\tiny\text{$ m,n $ and $ \log C $}
	%		\end{array} $}	
	%		\vspace{-3mm}

	\ccc{A.} No. If max capacity is \ccb{$C$}, then algorithm can take \ccb{$\geq C$} iterations.\pause

	\bigskip

	\begin{columns}
		\begin{column}{4cm}
			\begin{itemize}\color{blue}
				\item $s \rightarrow v \rightarrow w \rightarrow t$\
				\item $s \rightarrow w \rightarrow v \rightarrow t$
				\item $s \rightarrow v \rightarrow w \rightarrow t$
				\item $s \rightarrow w \rightarrow v \rightarrow t$
				\item $\dots$
				\item $s \rightarrow v \rightarrow w \rightarrow t$
				\item $s \rightarrow w \rightarrow v \rightarrow t$
			\end{itemize}

		\end{column}
		\begin{column}{6cm}
			\centerline{\includegraphics[width=\textwidth]{figures/p38}}
		\end{column}
	\end{columns}
}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%39

\frame{
	\frametitle{Network flow: quiz 4}
	The Ford–Fulkerson algorithm is guaranteed to terminate if the edge capacities are $\ldots$
	\begin{enumerate}[A.]
		\item Rational numbers.
		\item Real numbers.
		\item Both A and B.
		\item Neither A nor B.
	\end{enumerate}
}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%40

\frame{
	\frametitle{Choosing good augmenting paths}
	\ccp{Use care when selecting augmenting paths.}	\vspace{-3mm}
	\begin{itemize}
		\item Some choices lead to exponential algorithms.
		\item Clever choices lead to polynomial algorithms.
	\end{itemize}\pause\bigskip

	\ccp{Pathology.} When edge capacities can be irrational, no guarantee that Ford–Fulkerson terminates (or converges to a maximum flow)!
	\pause\bigskip

	\cco{Goal.}	Choose augmenting paths so that:\vspace{-3mm}
	\begin{itemize}
		\item Can find augmenting paths efficiently.
		\item Few iterations.
	\end{itemize}

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%41

\frame{
	\frametitle{Choosing good augmenting paths}
	\cco{Choose augmenting paths with:}	\vspace{-3mm}\pause
	\begin{itemize}
		\item Max bottleneck capacity(``fattest''). \pause
		\item Sufficiently large bottleneck capacity.\pause
		\item Fewest edges.
	\end{itemize}

	\centerline{\includegraphics[width=\textwidth,height=5cm]{figures/p41}}
}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%42

\frame{
	\frametitle{Capacity-scaling algorithm}
	\cco{Overview.}	 Choosing augmented paths with \ccp{large} bottleneck capacity.\pause
	\begin{itemize}
		\item Maintain scaling parameter \ccb{$\Delta$}.\pause
		\item Let \ccb{$G_f(\Delta)$} be the part of the residual network containing
		      only those edges with capacity \ccb{$\geq \Delta$}.\pause
		\item Any augmenting path in \ccb{$G_f(\Delta)$} has bottleneck capacity \ccb{$\geq \Delta$}.
	\end{itemize}

	\bigskip\centerline{\includegraphics[width=0.8\textwidth]{figures/p42}}
}



%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%43
\frame{
	\frametitle{Capacity-scaling algorithm}\vspace{5mm}

	\begin{exampleblock}{}
		\begin{algorithm}[H]
			\SetKwData{x}{x}\SetKwData{y}{y}\SetKwData{z}{z}
			\SetKwFunction{CS}{\sc Capacity-Scaling}\SetKwFunction{Return}{\sc Return}\SetKwFunction{Init}{\sc Initialize}
			\SetKwFunction{Up}{\sc Update}\SetKwFunction{Au}{\sc Augment}
			\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
			\CS{$G$}
			\BlankLine
			\For{each edge $e \in E$}{$f(e)\leftarrow 0$}
			$\Delta \leftarrow$ largest power of $2\leq C$\;
			\While{$\Delta\geq 1$}{
				$G_{f}(\Delta) \leftarrow \Delta$-residual network of $G$ with respect to flow $f$\;
				\While{there exists an $s\rightsquigarrow t$ path $P$ in $G_f (\Delta)$}{
					$f \leftarrow$ \Au{$f$, $c$, $P$}\;
					\Up{$G_\Delta(f)$}\;
				}
				$\Delta=\Delta/2$\;
			}
			\Return $f$\;
		\end{algorithm}
	\end{exampleblock}

}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%44
\frame{
	\frametitle{Capacity-scaling algorithm: proof of correctness}
	\ccc{Assumption.} All edge capacities are integers between \ccb{$1$} and \ccb{$C$}.\pause\bigskip


	\cco{Invariant.} The scaling parameter \ccb{$\Delta$} is a power of \ccb{$2$}.\pause

	\ccm{\em Proof.} Initially a power of \ccb{$2$}; each phase divides \ccb{$\Delta$} by exactly \ccb{$2$}.\pause\bigskip

	\cco{Integrality invariant.} Throughout the algorithm, every edge flow \ccb{$f(e)$} and residual capacity \ccb{$c_f (e)$} is an integer. \pause

	\ccm{\em Proof.}  Same as for generic Ford–Fulkerson.

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%44

\frame{
	\frametitle{Capacity-scaling algorithm: proof of correctness}


	\begin{theorem}
		If capacity-scaling algorithm terminates, then \ccb{$f$} is a max flow.
	\end{theorem}\pause

	\ccm{\em Proof.}\pause
	\begin{itemize}
		\item By integrality invariant, when \ccb{$\Delta=1$} \ccc{$\Rightarrow$} \ccb{$G_{f}(\Delta)=G_{f}$}
		\item Upon termination of \ccb{$\Delta=1$} phase, there are no augmenting paths.
		\item Result follows augmenting path theorem.
	\end{itemize}

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

\frame{
	\frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{block}{Lemma 1}
		There are \ccb{$1+\left\lfloor\log _{2} C\right\rfloor$} scaling phases.
	\end{block}

	%\ccm{\em Proof.} Initially \ccb{$C / 2<\Delta \leq C$}; \ccb{$\Delta$} decreases by a factor of 2 in each iteration.

	\begin{block}{Lemma 2}
		There are \ccb{$\leq 2m$} augmentations per scaling phase.
	\end{block}

	\begin{block}{Lemma 3}
		Let \ccb{$f$} be the flow at the end of a \ccb{$\Delta$}-scaling phase.\\
		Then, the max-flow value \ccb{$\leq \operatorname{val}(f)+m \Delta$}.
	\end{block}
	%\ccm{\em Proof.} Next slide.\pause


}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

\frame{
	\frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{theorem}
		The capacity-scaling algorithm takes \ccb{$O(m^2 log C)$} time.
	\end{theorem}	\pause
	\ccm{\em Proof.}\vspace{-2mm}\pause
	\begin{itemize}
		\item Lemma 1+ Lemma 2 \ccc{$\Rightarrow$} \ccb{$O(m \log C)$} augmentations.
		\item Finding an augmenting path takes \ccb{$O(m)$} time.
	\end{itemize}

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

\frame{
	\frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{block}{Lemma 1}
		There are \ccb{$1+\left\lfloor\log _{2} C\right\rfloor$} scaling phases.
	\end{block}\pause

	\ccm{\em Proof.} Initially \ccb{$C / 2<\Delta \leq C$}; \ccb{$\Delta$} decreases by a factor of 2 in each iteration.

}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45


\frame{
	\frametitle{Capacity-scaling algorithm: analysis of running time}

	\begin{block}{Lemma 2}
		There are \ccb{$\leq 2m$} augmentations per scaling phase.
	\end{block}\pause

	\ccm{\em Proof.} %\hspace{7cm}\ccr{ $ \begin{array}{l}
	%	\quad\tiny\text{or equivalently}\\[-2mm]
	%	\quad~\tiny\text{at the end}\\[-2mm]
	%	\tiny\text{of a 2$\Delta$-scaling phase}\\
	%	\qquad\swarrow\\
	%	\end{array} $}\vspace{-6mm}
	\begin{itemize}
		\item Let \ccb{$f$} be the flow at the beginning of a $\Delta$-scaling phase.
		\item Lemma 3 \ccc{$\Rightarrow$} max-flow value  \ccb{$\leq {val}(f)+m(2 \Delta)$}.
		\item Each augmentation in a $\Delta$-phase increases \ccb{$val(f)$} by at least \ccb{$\Delta$}.

	\end{itemize}

}
%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%46

\frame{
	\frametitle{Capacity-scaling algorithm: analysis of running time}
	\begin{block}{Lemma 3}
		Let \ccb{$f$} be the flow at the end of a \ccb{$\Delta$}-scaling phase.\\
		Then, the max-flow value \ccb{$\leq \operatorname{val}(f)+m \Delta$}.
	\end{block}\pause

	\ccm{\em Proof.} \vspace{-4mm}\pause
	\begin{itemize}
		\item We show there exists a cut \ccb{$(A, B)$} such that \ccb{$cap(A, B)\leq val(f) + m \Delta$}.
		\item Choose \ccb{$A$} to be the set of nodes reachable from \ccb{$s$} in \ccb{$G_f (\Delta)$}.
		\item By definition of \ccb{$A: s \in A$}.
		\item By definition of flow \ccb{$f: t \notin A$}.
	\end{itemize}
	\bigskip\pause

	\begin{columns}
		\hspace{2mm}	\begin{column}{6cm}
			\ccb{$\begin{array}{ll}
						val(f) & =\sum\limits_{e \text { out of } A} f(e)-\sum\limits_{e \text { in to } A} f(e)                                                 \\
						%\ccr{ \begin{array}{l}
						%			~~\nearrow\\[-2mm]
						%			\tiny\text{flow}\\[-2mm]
						%			\tiny\text{value}\\[-2mm]			
						%			\tiny\text{lemma}
						%		\end{array} }
						       & \geq \sum\limits_{e \text { out of } A}(c(e)-\Delta)-\sum\limits_{\text { e in to } A} \Delta                                   \\
						       & \geq \sum\limits_{e \text { out of } A} c(e)-\sum\limits_{e \text { out of } A} \Delta-\sum\limits_{e \text { in to } A} \Delta \\
						       & \geq \operatorname{cap}(A, B)-m \Delta
					\end{array}$}
		\end{column}

		\begin{column}{5cm}
			\vspace{3mm}\centerline{\includegraphics[width=0.8\textwidth]{figures/p46}}
		\end{column}
	\end{columns}

}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%45

\section{More about meta-learning and MAML}

%%%%//////////////////////////////////////////////////////////////////////////////////////////////%%48
%%
\frame{
	\frametitle{Shortest augmenting path}
	\ccr{Q.} How to choose next augmenting path in Ford–Fulkerson? \pause

	\ccc{A.}  Pick one that uses the \ccp{fewest} edges.\pause


}
%%//////////////////////////////////////////////////////////////////////////////////////////////%%58
\end{document}